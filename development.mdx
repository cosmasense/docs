---
title: 'Backend Architecture'
description: 'Understanding CosmaSense backend architecture and development'
---

<Info>
  **Prerequisites**:
  - Python 3.10 or higher (3.11+ recommended)
  - Basic understanding of async/await patterns
  - SQLite3
</Info>

## Architecture Overview

CosmaSense uses a monorepo structure with three main packages:

- **Backend** (`packages/cosma-backend`): Quart async web framework + Uvicorn
- **TUI** (`packages/cosma-tui`): Textual framework for terminal UI
- **CLI** (root): Click-based orchestrator

All packages share dependencies via workspace configuration.

## Tech Stack

### Backend Framework

| Component | Technology |
|-----------|-----------|
| Web Framework | Quart (async Flask) |
| ASGI Server | Uvicorn |
| Validation | QuartSchema |
| Database | asqlite (async SQLite) |
| File Watching | watchdog |

### AI & Search

| Component | Technology |
|-----------|-----------|
| Vector Search | sqlite-vec |
| Keyword Search | FTS5 (Full-Text Search) |
| LLM Backend | LiteLLM/Ollama |
| Embeddings | sentence-transformers (e5-base-v2) |
| File Parsing | MarkItDown (20+ formats) |

## Processing Pipeline

Files go through a 4-stage pipeline (see `pipeline.py:56-174`):

<Steps>
<Step title="Discovery">
Recursively scan directories and collect file metadata. Only files with modified timestamps different from the database are processed.

```python
# Skip logic checks modified time
if file.modified_time == db_modified_time:
    skip_file()
```
</Step>

<Step title="Parsing">
Extract text from 20+ file formats using MarkItDown. Calculate content hash to detect changes.

**Supported formats:**
- Documents: PDF, DOCX, TXT, MD
- Images: PNG, JPG, GIF (with OCR)
- Code: PY, JS, TS, JAVA, etc.
- Spreadsheets: XLSX, CSV

```python
# Hash check to detect content changes
if calculate_hash(content) == db_hash:
    skip_to_next_stage()
```
</Step>

<Step title="Summarization">
AI generates:
- Title
- Summary (max 100 words)
- 3-5 relevant keywords

Uses LiteLLM or Ollama for local/cloud LLM support.
</Step>

<Step title="Embedding">
Create 768-dimensional vectors using the e5-base-v2 model for semantic search.

Embeddings stored in `file_embeddings` virtual table with triggers to keep in sync.
</Step>
</Steps>

## Hybrid Search System

CosmaSense combines two search methods (see `searcher.py:91-220`):

### Semantic Search (Vector Similarity)

- Embeds query using same e5-base-v2 model
- Calculates cosine similarity against file embeddings
- Score: `exp(-distance)` scaled to 0-0.5 range

### Keyword Search (FTS5)

- SQLite FTS5 searches content/title/keywords
- Uses BM25 ranking algorithm
- Score: relevance scaled to 0-0.5 range

### Combined Scoring

```
final_score = semantic_score + keyword_score
```

Results sorted by combined score in descending order.

## Database Schema

See `schema.sql` for full details:

```sql
-- Core file data
CREATE TABLE files (
  path TEXT PRIMARY KEY,
  content TEXT,
  title TEXT,
  summary TEXT,
  keywords TEXT,
  hash TEXT,
  status TEXT,
  modified_time INTEGER
);

-- Vector search (sqlite-vec)
CREATE VIRTUAL TABLE file_embeddings USING vec0(
  embedding FLOAT[768]
);

-- Keyword search (FTS5)
CREATE VIRTUAL TABLE files_fts USING fts5(
  content, title, keywords
);
```

Triggers keep all three tables synchronized automatically.

## Async Programming in CosmaSense

CosmaSense uses Python's async/await for non-blocking I/O operations.

### Key Concepts

<CodeGroup>

```python Defining Async Functions
# Use 'async def' to create async functions
async def fetch_data():
    result = await database.query()
    return result

# Call with 'await'
data = await fetch_data()
```

```python Async Context Managers
# Database connections use 'async with'
async with app.db.acquire() as conn:
    files = await conn.fetchall("SELECT * FROM files;")
# Connection auto-closed after block
```

```python Running Sync Code in Async
# For long-running sync functions
import asyncio

def slow_operation(data):
    time.sleep(10)  # This would freeze async code
    return process(data)

# Correct way: run in thread pool
result = await asyncio.to_thread(slow_operation, my_data)
```

</CodeGroup>

<Warning>
**Critical**: Never use `time.sleep()` in async functions! It will freeze the entire app. Use `await asyncio.sleep()` instead.
</Warning>

## Real-time Updates

### Server-Sent Events (SSE)

The backend uses SSE to push updates to the TUI:

```
event: update
data: {"opcode": "file_parsing", "data": {"path": "/path/to/file.txt", "filename": "file.txt"}}
```

Events are published via an internal Hub and streamed to clients as SSE `update` events. Each event has an `opcode` and a `data` payload.

**Event categories:**
- **File processing**: `file_parsing`, `file_parsed`, `file_summarizing`, `file_summarized`, `file_embedding`, `file_embedded`, `file_complete`, `file_failed`, `file_skipped`
- **File system**: `file_created`, `file_modified`, `file_deleted`, `file_moved`, `directory_deleted`, `directory_moved`
- **Queue**: `queue_item_added`, `queue_item_updated`, `queue_item_processing`, `queue_item_completed`, `queue_item_failed`, `queue_item_removed`, `queue_paused`, `queue_resumed`
- **Scheduler**: `scheduler_paused`, `scheduler_resumed`
- **Watch**: `watch_started`, `watch_added`, `watch_removed`
- **General**: `status_update`, `error`, `info`, `shutting_down`

See the [Real-time Updates API reference](/api-reference/endpoint/updates) for full details.

### File Watching

Uses `watchdog` library to monitor filesystem changes:

```python
# Auto-reindex when files change
watcher.schedule(handler, path, recursive=True)
```

## Development Setup

<Steps>
<Step title="Clone Repository">
```bash
git clone https://github.com/cosmasense/cosma.git
cd cosma
```
</Step>

<Step title="Install Dependencies">
```bash
pip install -r requirements.txt

# For development
pip install -r requirements-dev.txt
```
</Step>

<Step title="Run Backend">
```bash
# Start backend server (port 60534)
cosma serve

# Or with debug logging
DEBUG=1 cosma serve
```
</Step>

<Step title="Run TUI">
```bash
# In another terminal
cosma search
```
</Step>
</Steps>

## Testing

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=cosma_backend

# Run specific test file
pytest tests/test_pipeline.py
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="RuntimeWarning: coroutine was never awaited">
    You forgot to use `await` when calling an async function:

    ```python
    # Wrong
    result = async_function()

    # Correct
    result = await async_function()
    ```
  </Accordion>

  <Accordion title="App freezes during file processing">
    You're running blocking code in an async function. Use `asyncio.to_thread()`:

    ```python
    # Wrong
    async def process():
        slow_operation()  # Blocks event loop

    # Correct
    async def process():
        await asyncio.to_thread(slow_operation)
    ```
  </Accordion>

  <Accordion title="Database locked errors">
    Multiple async operations trying to write simultaneously. Use proper connection pooling:

    ```python
    async with app.db.acquire() as conn:
        await conn.execute("INSERT ...")
    ```
  </Accordion>
</AccordionGroup>

## Further Reading

- [Quart Documentation](https://quart.palletsprojects.com/)
- [Python Async I/O Guide](https://realpython.com/async-io-python/)
- [SQLite FTS5 Documentation](https://www.sqlite.org/fts5.html)
- [sqlite-vec GitHub](https://github.com/asg017/sqlite-vec)
